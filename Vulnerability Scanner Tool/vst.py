import nmap
import requests
from bs4 import BeautifulSoup
import json
import concurrent.futures
from jinja2 import Environment, FileSystemLoader
import os

def scan_ports(target):
    nm = nmap.PortScanner()
    nm.scan(target, '1-65535', arguments='-sV')
    open_ports = []

    for host in nm.all_hosts():
        for proto in nm[host].all_protocols():
            lport = nm[host][proto].keys()
            for port in lport:
                if nm[host][proto][port]['state'] == 'open':
                    service = nm[host][proto][port]['name']
                    version = nm[host][proto][port]['version']
                    open_ports.append((port, service, version))
    return open_ports

def check_web_vulnerabilities(target, open_ports):
    web_vulnerabilities = []
    for port, service, version in open_ports:
        if service == 'http' or service == 'https':
            url = f"http://{target}:{port}" if service == 'http' else f"https://{target}:{port}"
            try:
                response = requests.get(url)
                if 'X-XSS-Protection' not in response.headers:
                    web_vulnerabilities.append((port, 'XSS Protection Header Missing', 'Potential XSS vulnerability'))
                if 'X-Content-Type-Options' not in response.headers:
                    web_vulnerabilities.append((port, 'Content Type Options Header Missing', 'Potential MIME-Sniffing vulnerability'))
                # Add more checks here as needed
            except requests.exceptions.RequestException as e:
                print(f"Error accessing {url}: {e}")
    return web_vulnerabilities

def fetch_cve_details(service, version):
    search_query = f"{service} {version}"
    url = f"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={search_query}"
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    cve_table = soup.find('table', {'class': 'searchresults'})
    
    cve_list = []
    if cve_table:
        rows = cve_table.find_all('tr')[1:]
        for row in rows:
            cols = row.find_all('td')
            if len(cols) >= 2:
                cve_id = cols[0].text.strip()
                cve_desc = cols[1].text.strip()
                cve_list.append((cve_id, cve_desc))
    return cve_list

def generate_html_report(report_data, target):
    env = Environment(loader=FileSystemLoader('.'))
    template = env.get_template('template.html')
    output_from_parsed_template = template.render(target=target, open_ports=report_data['open_ports'], web_vulnerabilities=report_data.get('web_vulnerabilities', []))
    
    with open(f"{target}_vulnerability_report.html", "w") as report_file:
        report_file.write(output_from_parsed_template)

    print(f"HTML report saved to {target}_vulnerability_report.html")

def vulnerability_scanner(target):
    print(f"Scanning target: {target}")
    open_ports = scan_ports(target)
    if not open_ports:
        print("No open ports found.")
        return

    report = {"target": target, "open_ports": []}
    
    def scan_port_details(port, service, version):
        cves = fetch_cve_details(service, version)
        port_info = {
            "port": port,
            "service": service,
            "version": version,
            "vulnerabilities": cves
        }
        report["open_ports"].append(port_info)
        return port_info

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(scan_port_details, port, service, version) for port, service, version in open_ports]
        for future in concurrent.futures.as_completed(futures):
            port_info = future.result()
            print(f"Port {port_info['port']} - Service: {port_info['service']}, Version: {port_info['version']}")
            for cve_id, cve_desc in port_info["vulnerabilities"]:
                print(f"  - {cve_id}: {cve_desc}")

    web_vulnerabilities = check_web_vulnerabilities(target, open_ports)
    report["web_vulnerabilities"] = web_vulnerabilities

    generate_html_report(report, target)

if __name__ == "__main__":
    target = input("Enter the target IP address: ")
    vulnerability_scanner(target)
